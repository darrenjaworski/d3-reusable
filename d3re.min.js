(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["d3re"] = factory();
	else
		root["d3re"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ChartDefault; });
var ChartDefault = {
  margin: {
    top: 10,
    right: 30,
    bottom: 30,
    left: 30,
  },
  width: 1000 - 30 - 30,
  height: 500 - 10 - 30,
};


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = bar;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_is_css_color__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_is_css_color___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_is_css_color__);


function bar() {
  let data = [];
  let width = 600;
  let height = 400;
  let barPadding = 1;
  let fillColor = 'steelblue';
  let durationTime = 750;
  let accessor = null;
  let isVertical = false;

  const accessorFunction = d => d;

  let updateData;

  function chart(selection) {
    selection.each(function (d) {
      const dom = d3.select(this);
      const svg = dom.append('svg').attr('height', height).attr('width', width);
      const t = d3.transition().duration(durationTime);

      updateData = function () {
        const config = {
          dirAxis: isVertical ? 'x' : 'y',
          dirValue: isVertical ? 'width' : 'height',
          compAxis: isVertical ? 'y' : 'x',
          compValue: isVertical ? 'height' : 'width',
        };

        const barSpacing = isVertical ? width / data.length : height / data.length;
        const barSize = barSpacing - barPadding;
        const maxValue = d3.max(data, accessorFunction);
        const barLength = isVertical ? height / maxValue : width / maxValue;

        // join
        const bars = svg.selectAll('rect').data(data);

        // exit
        bars.exit().transition(t).style('opacity', 0).remove();

        // update
        bars
          .style('opacity', 1)
          .transition(t)
          .attr(config.dirAxis, (d, i) => i * barSpacing)
          .attr(config.dirValue, barSize);

        // enter
        bars
          .enter()
          .append('rect')
          .attr(config.dirAxis, (d, i) => i * barSpacing)
          .attr(config.dirValue, barSize)
          .attr(config.compAxis, 0)
          .attr(config.compValue, 0)
          .style('fill', fillColor)
          .style('opacity', 0)
          .transition(t)
          .style('opacity', 1)
          .attr(config.compValue, d => d * barLength);
      };

      updateData();
    });
  }

  chart.data = function (_) {
    if (!arguments.length) return data;
    data = _;
    if (typeof updateData === 'function') updateData();
    return chart;
  };

  chart.width = function (_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function (_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.barPadding = function (_) {
    if (!arguments.length) return barPadding;
    barPadding = _;
    return chart;
  };

  chart.accessor = function (_) {
    if (!arguments.length) return accessor;
    accessor = _;
    return chart;
  };

  chart.duration = function (_) {
    if (!arguments.length) return durationTime;
    durationTime = _;
    return chart;
  };

  chart.fillColor = function (_) {
    if (!arguments.length) return fillColor;

    // must be a valid color
    if (!__WEBPACK_IMPORTED_MODULE_0_is_css_color___default()(_)) {
      console.warn(`${_} is not a valid color. Try a hex, rgb, hsl or named css color.`);
      return chart;
    }
    fillColor = _;
    return chart;
  };

  chart.isVertical = function (_) {
    if (!arguments.length) return isVertical;

    // must be a valid boolean value
    if (typeof _ !== 'boolean') {
      console.warn('Value passed to the isVertical function must be a boolean.');
      return chart;
    }
    isVertical = _;
    return chart;
  };

  return chart;
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = histogram;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defaults__ = __webpack_require__(0);


function histogram() {
  let updateData;
  let data = [];
  let margin = __WEBPACK_IMPORTED_MODULE_0__defaults__["a" /* ChartDefault */].margin;
  let width = __WEBPACK_IMPORTED_MODULE_0__defaults__["a" /* ChartDefault */].width;
  let height = __WEBPACK_IMPORTED_MODULE_0__defaults__["a" /* ChartDefault */].height;

  const x = d3.scaleLinear().range([0, width]);

  const y = d3.scaleLinear().range([height, 0]);

  const histogram = d3.histogram().value(d => d);

  function chart(selection) {
    selection.each(function () {
      const t = d3.transition().duration(750);
      const dom = d3.select(this);

      const svg = dom
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      const xAxis = svg
        .append('g')
        .attr('class', 'axis axis--x')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x));

      updateData = function () {
        x.domain(d3.extent(data, d => d));

        const bins = histogram.domain(x.domain()).thresholds(x.ticks(10))(data);

        y.domain([0, d3.max(bins, d => d.length)]);

        // join
        const g = svg.selectAll('.bar').data(bins);

        // exit
        g.exit().transition(t).style('opacity', 0).remove();

        // update
        g
          .style('opacity', 1)
          .transition(t)
          .attr('transform', d => `translate(${x(d.x0)},${y(d.length)})`);

        // enter
        const bar = g
          .enter()
          .append('g')
          .attr('class', 'bar')
          .attr('transform', d => `translate(${x(d.x0)},${y(d.length)})`);

        bar
          .append('rect')
          .attr('x', 1)
          .attr('width', d => x(d.x1) - x(d.x0) - 1)
          .attr('height', d => height - y(d.length));

        bar
          .append('text')
          .attr('dy', '.75em')
          .attr('y', 6)
          .attr('x', d => (x(d.x1) - x(d.x0)) / 2)
          .attr('text-anchor', 'middle')
          .text(d => d.length);
      };

      updateData();
    });
  }

  chart.data = function (_) {
    if (!arguments.length) return data;
    data = _;
    if (typeof updateData === 'function') updateData();
    return chart;
  };

  chart.margin = function (_) {
    if (!arguments.length) return margin;
    margin = _;
    return chart;
  };

  chart.width = function (_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function (_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  return chart;
}


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = line;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defaults__ = __webpack_require__(0);


function line() {
  const margin = { top: 20, right: 30, bottom: 30, left: 20 };
  let width = 1000;
  let height = 500;
  let data = [];
  let updateData;
  let yLower;
  let yUpper;
  let colorArr = d3.schemeCategory10;

  function chart(selection) {
    selection.each(function () {
      width = width - margin.left - margin.right;
      height = height - margin.top - margin.bottom;
      yLower =
        typeof yLower !== 'undefined'
          ? yLower
          : d3.min(data.feeds, f => d3.min(f.values, d => d.y));
      yUpper =
        typeof yUpper !== 'undefined'
          ? yUpper
          : d3.max(data.feeds, f => d3.max(f.values, d => d.y));

      const x = d3
        .scaleTime()
        .range([0, width])
        .domain([
          d3.min(data.feeds, f => d3.min(f.values, d => d.x)),
          d3.max(data.feeds, f => d3.max(f.values, d => d.x)),
        ]);

      const y = d3.scaleLinear().range([height, 0]).domain([yLower, yUpper]).nice();

      const color = d3.scaleOrdinal(colorArr).domain(data.feeds.map(f => f.id));

      const line = d3.line().curve(d3.curveBasis).x(d => x(d.x)).y(d => y(d.y));

      const dom = d3.select(this);
      const svg = dom
        .append('svg')
        .attr('height', height + margin.top + margin.bottom)
        .attr('width', width + margin.left + margin.right);

      const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

      g
        .append('g')
        .attr('class', 'axis axis--x')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x));

      g.append('g').attr('class', 'axis axis--y').call(d3.axisLeft(y));

      const feed = g.selectAll('.feed').data(data.feeds).enter().append('g').attr('class', 'feed');

      feed
        .append('path')
        .attr('class', 'line')
        .style('fill', 'none')
        .style('stroke-width', '2px')
        .attr('d', d => line(d.values))
        .style('stroke', d => color(d.id));

      // feed.append("text")
      //   .datum(function(d) { return {id: d.id, value: d.values[d.values.length - 1]}; })
      //   .attr("transform", function(d) { return "translate(" + x(d.value.x) + "," + y(d.value.y) + ")"; })
      //   .attr("x", 3)
      //   .attr("dy", "0.35em")
      //   .style("font", "10px sans-serif")
      //   .text(function(d) { return d.id; });

      updateData = function () {
        const t = d3.transition().duration(750);

        const updateFeed = g.selectAll('.feed').data(data.feeds);

        const line = updateFeed.selectAll('.line');

        // updateFeed.enter()
        //   .append('g')
        //   .attr('class', 'feed')
        //   .append('path')
        //   .attr('class', 'line')
        //   .attr('d', '')
        //   .style('fill', 'none')
        //   .style('stroke-width', '1.5px')
        //   .style('opacity', 0)
        //   .transition(t)
        //   .delay(function(d, i) { return (data.length - i) * 40; })
        //   .attr('d', function(d) { return line(d.values); })
        //   .style('stroke', function(d) { return color(d.id); })
        //   .style('opacity', 1);
        //
        // update.exit()
        //   .transition(t)
        //   .style('opacity', 0)
        //   .remove();
      };
    });
  }

  chart.showWatch = function (_) {
    if (!arguments.length) return showWatch;
    if (typeof _ !== 'boolean') return showWatch;
    showWatch = _;
    return chart;
  };

  chart.showWarning = function (_) {
    if (!arguments.length) return showWarning;
    if (typeof _ !== 'boolean') return showWarning;
    showWatch = _;
    return chart;
  };

  chart.data = function (_) {
    if (!arguments.length) return data;
    data = _;
    if (typeof updateData === 'function') updateData();
    return chart;
  };

  chart.width = function (_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function (_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.yLower = function (_) {
    if (!arguments.length) return yLower;
    // if ()
    yLower = _;
    return chart;
  };

  chart.yUpper = function (_) {
    if (!arguments.length) return yUpper;
    yUpper = _;
    return chart;
  };

  chart.colorArray = function (_) {
    if (!arguments.length) return colorArr;
    colorArr = _;
    return chart;
  };

  return chart;
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//every string I match against are lowercase
var HEX_PATTERN = /^#(?:[a-f0-9]{3})?(?:[a-f0-9]{3})$/;
// css color names + initial + inherit + currentColor + transparent
var CSS_COLOR_NAMES = [
  'aliceblue',
  'antiquewhite',
  'aqua',
  'aquamarine',
  'azure',
  'beige',
  'bisque',
  'black',
  'blanchedalmond',
  'blue',
  'blueviolet',
  'brown',
  'burlywood',
  'cadetblue',
  'chartreuse',
  'chocolate',
  'coral',
  'cornflowerblue',
  'cornsilk',
  'crimson',
  'currentColor',
  'cyan',
  'darkblue',
  'darkcyan',
  'darkgoldenrod',
  'darkgray',
  'darkgreen',
  'darkgrey',
  'darkkhaki',
  'darkmagenta',
  'darkolivegreen',
  'darkorange',
  'darkorchid',
  'darkred',
  'darksalmon',
  'darkseagreen',
  'darkslateblue',
  'darkslategray',
  'darkslategrey',
  'darkturquoise',
  'darkviolet',
  'deeppink',
  'deepskyblue',
  'dimgray',
  'dimgrey',
  'dodgerblue',
  'firebrick',
  'floralwhite',
  'forestgreen',
  'fuchsia',
  'gainsboro',
  'ghostwhite',
  'gold',
  'goldenrod',
  'gray',
  'green',
  'greenyellow',
  'grey',
  'honeydew',
  'hotpink',
  'indianred',
  'indigo',
  'inherit',
  'initial',
  'ivory',
  'khaki',
  'lavender',
  'lavenderblush',
  'lawngreen',
  'lemonchiffon',
  'lightblue',
  'lightcoral',
  'lightcyan',
  'lightgoldenrodyellow',
  'lightgray',
  'lightgreen',
  'lightgrey',
  'lightpink',
  'lightsalmon',
  'lightseagreen',
  'lightskyblue',
  'lightslategray',
  'lightslategrey',
  'lightsteelblue',
  'lightyellow',
  'lime',
  'limegreen',
  'linen',
  'magenta',
  'maroon',
  'mediumaquamarine',
  'mediumblue',
  'mediumorchid',
  'mediumpurple',
  'mediumseagreen',
  'mediumslateblue',
  'mediumspringgreen',
  'mediumturquoise',
  'mediumvioletred',
  'midnightblue',
  'mintcream',
  'mistyrose',
  'moccasin',
  'navajowhite',
  'navy',
  'oldlace',
  'olive',
  'olivedrab',
  'orange',
  'orangered',
  'orchid',
  'palegoldenrod',
  'palegreen',
  'paleturquoise',
  'palevioletred',
  'papayawhip',
  'peachpuff',
  'peru',
  'pink',
  'plum',
  'powderblue',
  'purple',
  'rebeccapurple',
  'red',
  'rosybrown',
  'royalblue',
  'saddlebrown',
  'salmon',
  'sandybrown',
  'seagreen',
  'seashell',
  'sienna',
  'silver',
  'skyblue',
  'slateblue',
  'slategray',
  'slategrey',
  'snow',
  'springgreen',
  'steelblue',
  'tan',
  'teal',
  'thistle',
  'tomato',
  'transparent',
  'turquoise',
  'violet',
  'wheat',
  'white',
  'whitesmoke',
  'yellow',
  'yellowgreen',
];

var PREFIX = '^(rgb|hsl)(a?)\\s*\\(';
var VALUE = '\\s*([-+]?\\d+%?)\\s*';
var ALPHA = '(?:,\\s*([-+]?(?:(?:\\d+(?:\.\\d+)?)|(?:\.\\d+))\\s*))?';
var SUFFIX = '\\)$';
var RGB_HSL_PATTERN = new RegExp(PREFIX + VALUE + ',' + VALUE + ',' + VALUE + ALPHA + SUFFIX);

var NUM_TYPE = 1;
var PERCENTAGE_TYPE = 2;
var ERROR_TYPE = NUM_TYPE & PERCENTAGE_TYPE;

module.exports = function(str) {
  function getColorType(token) {
    return token.indexOf('%') !== -1 ? PERCENTAGE_TYPE : NUM_TYPE;
  }

  if(!str || typeof str !== 'string') {
    return false;
  }

  var color = str.replace(/^\s+|\s+$/g, '').toLocaleLowerCase();

  // named colors or hex code
  if((CSS_COLOR_NAMES.indexOf(color) !== -1) || HEX_PATTERN.test(color)) {
    return true;
  }

  var result = color.match(RGB_HSL_PATTERN);
  if(result) {
    var flavor = result[1];
    var alpha = result[2];
    var rh = result[3];
    var gs = result[4];
    var bl = result[5];
    var a = result[6];

    // alpha test
    if((alpha === 'a' && !a) || (a && alpha === '')) {
      return false;
    }

    // hsl
    if(flavor === 'hsl') {
      if(getColorType(rh) !== NUM_TYPE) {
        return false;
      }
      return (getColorType(gs) & getColorType(bl)) === PERCENTAGE_TYPE;
    }

    // rgb
    return (getColorType(rh) & getColorType(gs) & getColorType(bl)) !== ERROR_TYPE;
  }

  return false;
};


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_bar__ = __webpack_require__(1);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "bar", function() { return __WEBPACK_IMPORTED_MODULE_0__lib_bar__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_histogram__ = __webpack_require__(2);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return __WEBPACK_IMPORTED_MODULE_1__lib_histogram__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_line__ = __webpack_require__(3);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "line", function() { return __WEBPACK_IMPORTED_MODULE_2__lib_line__["a"]; });





/***/ })
/******/ ]);
});