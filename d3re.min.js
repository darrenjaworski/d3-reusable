(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["d3re"] = factory();
	else
		root["d3re"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = bar;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_is_css_color__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_is_css_color___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_is_css_color__);


function bar() {
  let data = [];
  let width = 600;
  let height = 400;
  let barPadding = 1;
  let fillColor = 'steelblue';
  let durationTime = 750;
  let accessor = null;
  let isVertical = false;
  const accessorFunction = d => d;

  let updateData;

  function chart(selection) {
    selection.each(function eachSelection() {
      const dom = d3.select(this);
      const svg = dom.append('svg').attr('height', height).attr('width', width);
      const t = d3.transition().duration(durationTime);

      updateData = () => {
        const config = {
          dirAxis: isVertical ? 'x' : 'y',
          dirValue: isVertical ? 'width' : 'height',
          compAxis: isVertical ? 'y' : 'x',
          compValue: isVertical ? 'height' : 'width',
        };

        const barSpacing = isVertical ? width / data.length : height / data.length;
        const barSize = barSpacing - barPadding;
        const maxValue = d3.max(data, accessorFunction);
        const barLength = isVertical ? height / maxValue : width / maxValue;

        // join
        const bars = svg.selectAll('rect').data(data);

        // exit
        bars.exit().transition(t).style('opacity', 0).remove();

        // update
        bars
          .style('opacity', 1)
          .transition(t)
          .attr(config.dirAxis, (d, i) => i * barSpacing)
          .attr(config.dirValue, barSize);

        // enter
        bars
          .enter()
          .append('rect')
          .attr(config.dirAxis, (d, i) => i * barSpacing)
          .attr(config.dirValue, barSize)
          .attr(config.compAxis, 0)
          .attr(config.compValue, 0)
          .style('fill', fillColor)
          .style('opacity', 0)
          .transition(t)
          .style('opacity', 1)
          .attr(config.compValue, d => d * barLength);
      };

      updateData();
    });
  }

  chart.data = function dataFn(_) {
    if (!arguments.length) return data;
    data = _;
    if (typeof updateData === 'function') updateData();
    return chart;
  };

  chart.width = function widthFn(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function heightFn(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.barPadding = function barPaddingFn(_) {
    if (!arguments.length) return barPadding;
    barPadding = _;
    return chart;
  };

  chart.accessor = function accessorFn(_) {
    if (!arguments.length) return accessor;
    accessor = _;
    return chart;
  };

  chart.duration = function durationFn(_) {
    if (!arguments.length) return durationTime;
    durationTime = _;
    return chart;
  };

  chart.fillColor = function fillColorFn(_) {
    if (!arguments.length) return fillColor;

    // must be a valid color
    if (!__WEBPACK_IMPORTED_MODULE_0_is_css_color___default()(_)) {
      console.warn(`${_} is not a valid color. Try a hex, rgb, hsl or named css color.`);
      return chart;
    }
    fillColor = _;
    return chart;
  };

  chart.isVertical = function isVerticalFn(_) {
    if (!arguments.length) return isVertical;

    // must be a valid boolean value
    if (typeof _ !== 'boolean') {
      console.warn('Value passed to the isVertical function must be a boolean.');
      return chart;
    }
    isVertical = _;
    return chart;
  };

  return chart;
}


/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_bar__ = __webpack_require__(0);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "bar", function() { return __WEBPACK_IMPORTED_MODULE_0__lib_bar__["a"]; });



// export * from './lib/histogram';
// export * from './lib/line';


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//every string I match against are lowercase
var HEX_PATTERN = /^#(?:[a-f0-9]{3})?(?:[a-f0-9]{3})$/;
// css color names + initial + inherit + currentColor + transparent
var CSS_COLOR_NAMES = [
  'aliceblue',
  'antiquewhite',
  'aqua',
  'aquamarine',
  'azure',
  'beige',
  'bisque',
  'black',
  'blanchedalmond',
  'blue',
  'blueviolet',
  'brown',
  'burlywood',
  'cadetblue',
  'chartreuse',
  'chocolate',
  'coral',
  'cornflowerblue',
  'cornsilk',
  'crimson',
  'currentColor',
  'cyan',
  'darkblue',
  'darkcyan',
  'darkgoldenrod',
  'darkgray',
  'darkgreen',
  'darkgrey',
  'darkkhaki',
  'darkmagenta',
  'darkolivegreen',
  'darkorange',
  'darkorchid',
  'darkred',
  'darksalmon',
  'darkseagreen',
  'darkslateblue',
  'darkslategray',
  'darkslategrey',
  'darkturquoise',
  'darkviolet',
  'deeppink',
  'deepskyblue',
  'dimgray',
  'dimgrey',
  'dodgerblue',
  'firebrick',
  'floralwhite',
  'forestgreen',
  'fuchsia',
  'gainsboro',
  'ghostwhite',
  'gold',
  'goldenrod',
  'gray',
  'green',
  'greenyellow',
  'grey',
  'honeydew',
  'hotpink',
  'indianred',
  'indigo',
  'inherit',
  'initial',
  'ivory',
  'khaki',
  'lavender',
  'lavenderblush',
  'lawngreen',
  'lemonchiffon',
  'lightblue',
  'lightcoral',
  'lightcyan',
  'lightgoldenrodyellow',
  'lightgray',
  'lightgreen',
  'lightgrey',
  'lightpink',
  'lightsalmon',
  'lightseagreen',
  'lightskyblue',
  'lightslategray',
  'lightslategrey',
  'lightsteelblue',
  'lightyellow',
  'lime',
  'limegreen',
  'linen',
  'magenta',
  'maroon',
  'mediumaquamarine',
  'mediumblue',
  'mediumorchid',
  'mediumpurple',
  'mediumseagreen',
  'mediumslateblue',
  'mediumspringgreen',
  'mediumturquoise',
  'mediumvioletred',
  'midnightblue',
  'mintcream',
  'mistyrose',
  'moccasin',
  'navajowhite',
  'navy',
  'oldlace',
  'olive',
  'olivedrab',
  'orange',
  'orangered',
  'orchid',
  'palegoldenrod',
  'palegreen',
  'paleturquoise',
  'palevioletred',
  'papayawhip',
  'peachpuff',
  'peru',
  'pink',
  'plum',
  'powderblue',
  'purple',
  'rebeccapurple',
  'red',
  'rosybrown',
  'royalblue',
  'saddlebrown',
  'salmon',
  'sandybrown',
  'seagreen',
  'seashell',
  'sienna',
  'silver',
  'skyblue',
  'slateblue',
  'slategray',
  'slategrey',
  'snow',
  'springgreen',
  'steelblue',
  'tan',
  'teal',
  'thistle',
  'tomato',
  'transparent',
  'turquoise',
  'violet',
  'wheat',
  'white',
  'whitesmoke',
  'yellow',
  'yellowgreen',
];

var PREFIX = '^(rgb|hsl)(a?)\\s*\\(';
var VALUE = '\\s*([-+]?\\d+%?)\\s*';
var ALPHA = '(?:,\\s*([-+]?(?:(?:\\d+(?:\.\\d+)?)|(?:\.\\d+))\\s*))?';
var SUFFIX = '\\)$';
var RGB_HSL_PATTERN = new RegExp(PREFIX + VALUE + ',' + VALUE + ',' + VALUE + ALPHA + SUFFIX);

var NUM_TYPE = 1;
var PERCENTAGE_TYPE = 2;
var ERROR_TYPE = NUM_TYPE & PERCENTAGE_TYPE;

module.exports = function(str) {
  function getColorType(token) {
    return token.indexOf('%') !== -1 ? PERCENTAGE_TYPE : NUM_TYPE;
  }

  if(!str || typeof str !== 'string') {
    return false;
  }

  var color = str.replace(/^\s+|\s+$/g, '').toLocaleLowerCase();

  // named colors or hex code
  if((CSS_COLOR_NAMES.indexOf(color) !== -1) || HEX_PATTERN.test(color)) {
    return true;
  }

  var result = color.match(RGB_HSL_PATTERN);
  if(result) {
    var flavor = result[1];
    var alpha = result[2];
    var rh = result[3];
    var gs = result[4];
    var bl = result[5];
    var a = result[6];

    // alpha test
    if((alpha === 'a' && !a) || (a && alpha === '')) {
      return false;
    }

    // hsl
    if(flavor === 'hsl') {
      if(getColorType(rh) !== NUM_TYPE) {
        return false;
      }
      return (getColorType(gs) & getColorType(bl)) === PERCENTAGE_TYPE;
    }

    // rgb
    return (getColorType(rh) & getColorType(gs) & getColorType(bl)) !== ERROR_TYPE;
  }

  return false;
};


/***/ })
/******/ ]);
});